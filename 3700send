#!/usr/bin/env python3

import sys
import socket
import datetime
import json
import select


class Sender:

  def __init__(self):
    self.msg_size = 1500
    self.data_size = 1472
    self.timeout = 30
    self.rtt = 1.0
    self.rtt_delta = 0.875 
    self.rto = 2 * self.rtt
    self.ack_receive_time = -1
    self.packet_cache = []
    self.timeout_timer = 0
    self.packets_sent = 0
    self.data_acked = 0

  def calculate_rtt(self, new_rtt):
    return float(self.rtt_delta * self.rtt) + float((1.0 - self.rtt_delta) * new_rtt)

  def get_time_difference_miliseconds(self,datetime_object1, datetime_object2):
    # https://stackoverflow.com/questions/1345827/how-do-i-find-the-time-difference-between-two-datetime-objects-in-python
    difference = datetime_object2 - datetime_object1
    return float(difference.total_seconds())

  def log(self,string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")
    sys.stderr.flush()

  def send_packet(self,sock,packet,dest):
    seqn = packet["sequence"]
    if sock.sendto(json.dumps(packet).encode('ascii'), dest) < len(packet):
      self.log("[error] unable to fully send packet")
    else:
      self.log("[send data] " + str(seqn) + " (" + str(len(packet["data"])) + ")")
      self.packets_sent += 1

  def send_next_packet(self,seqn, sock, dest):
    msg = {"sequence": seqn, "data": "", "ack": False, "eof": False}
    overhead = len(json.dumps(msg))
    msg["data"] = sys.stdin.read(self.data_size - overhead)
    if len(msg["data"]) > 0:
      assert (len(msg) <= self.data_size), f"ERROR: Datagram is longer ({len(msg)}) than {self.data_size} bytes!!!"
      self.send_packet(sock,msg,dest)
      self.packet_cache.append(msg)

      return seqn + len(msg["data"])
    return seqn

  # ACK looks like {"ack": sequence_number,
  #                 "unordered_sent_packages": []}
  def recognize_ack(self,ack):
    for packet in self.packet_cache:
      if packet["sequence"] < ack["ack"] or packet["sequence"] in ack["unordered_sent_packages"]:
        self.packet_cache.remove(packet)
    self.data_acked = int(ack["ack"])
      
  def check_for_timeout(self):
    time_now = datetime.datetime.now()
    delta = time_now - self.timeout_timer
    return delta.seconds > self.timeout



  def main(self,):
    # Bind to localhost and an ephemeral port
    ip_port = sys.argv[1]
    udp_ip = ip_port[0:ip_port.find(":")]
    udp_port = int(ip_port[ip_port.find(":")+1:])
    dest = (udp_ip, udp_port)
    seqn = 0

    # Set up the socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(self.timeout)
    sock.setblocking(0)
    self.timeout_timer = datetime.datetime.now()

    send_time = datetime.datetime.now()
    # Send first packet
    seqn = self.send_next_packet(seqn, sock, dest)
    
    # Now read in data, send packets
    while True:
      if self.packets_sent > 100:
        sys.exit(0)

      if self.check_for_timeout():
        self.log("[error] timeout")
        sys.exit(-1)

      self.log("ABOUT TO SLEEP")
      self.log(f"rto = {self.rto}")
      ready = select.select([sock], [], [], self.rto)
      
      if ready[0]:
        result = sock.recvfrom(self.msg_size)
        if result:
          (data, _addr) = result
          data = data.decode('ascii')

          try:
            decoded = json.loads(data)

            # If there is an ack, send next packet
            if decoded['ack'] == seqn:
              self.recognize_ack(decoded)
              self.ack_receive_time = datetime.datetime.now()
              new_rtt = self.get_time_difference_miliseconds(send_time,self.ack_receive_time)

              self.rtt = self.calculate_rtt(new_rtt)
              self.rto = self.rtt * 2
              if self.rto > 10:
                self.rto = 1
              self.log(f"[recv ack] {seqn}")

              send_time = datetime.datetime.now()
              # Try to send next packet; break if no more data
              new_seq = self.send_next_packet(seqn, sock, dest)
              if new_seq == seqn:
                self.log("no more data to read")
                break
              seqn = new_seq
          except (ValueError, KeyError, TypeError):
            self.log("[recv corrupt packet]")
      else: # We didn't get an ACK in enough time, resend everything in the cache
        for packet in self.packet_cache:
          if self.data_acked <= packet["sequence"]:
            self.send_packet(sock,packet,dest)
        
        if not self.packet_cache:
          self.log("no more data in the cache")
          break

      self.log(f"(seqn {seqn})")

    sock.sendto(json.dumps({"eof": True, "data": "", "sequence": seqn, "ack": False}).encode('ascii'), dest)
    sys.exit(0)

if __name__ == '__main__':
  s = Sender()
  s.main()
